\section{Introduction}

Dans cette partie, un branch and bound est mis en oeuvre pour résoudre le problème de SSCFLP.
Il fait appel à glpk pour la relaxation continue.

\section{Méthodes de branchement}

\subsection{Variable de branchement}

Il a d'abord été testé de brancher sur les services en premier lieu, et sur les clients en deuxième.
Le branchement sur un service permet ensuite d'induire un certain nombre d'affectation pour les clients.
En effet, un service affecté à 0 implique que tous les clients ne pourront pas lui être connecté et donc les variables correspondants à ces clients auront une valeur de 0. \newline

Dans la modélisation du problème, un client n'est affecté qu'à un seul service. Du coup, pas besoin de garder en mémoire toutes les variables de connexions.
Seulement un tableau des variables affectées et un tableau de service auxquels un client est affecté. \newline

\subsection{Couper dans l'arbre de recherche}

On peut également être malin dans le branch and bound en essayant d'exploiter des informations facilement au lieu de laisser glpk tour faire.
La contrainte à tester la plus évidente pour ça est le respect des capacités des services.
On peut mettre à jour progressivement les capacités restantes et couper à partir du moment où une capacité est négative.
On peut aussi mettre à jour la valeur de z -> on peut alors couper dès que la valeur de z dépasse la meilleure valeur connue -> on se passe du simplexe de la relaxation continue.

\subsection{Idée de borne inf}

Une borne inférieure pour couper dans l'arbre.
On peut calculer pour une affectation un coût plus petit que celui que l'on aura pour une affectation valide.
Pour cela, on calcule les valeurs minimales de coûts de connexions des services ouverts.
On sait que l'on dépensera au mieux cette somme pour l'ouverture. Si la somme est déjà supérieure au meilleur coût trouvé, pas la peine de résoudre.

\section{Bonnes solution de départ}

Pourquoi pas des fourmis ? Il faut une métaheuristique surefficace. Le but est d'aller passer du temps uniquement les branches prometteuses.
On veut couper le plus facilement possible les autres branches. \newline

Parcours d'une fourmi : La fourmi commence avec une solution vide, aucun client n'est connecté et aucun service n'est ouvert.
à chaque étape, elle connecte un client. Les clients sont pris dans l'ordre.
Le choix du service auquel connecter le client est fait par une roulette biaisée à partir des traces de phéromones présentes pour chaque choix.
Les phéromones sont donc un tableau deux dimensions de nbClient x nbServices.
Après le passage de chaque fourmi d'une itération les phéromones sont mise à jours.
Si le passage est un passage appartient à une solution améliorant la solution, alors la trace de phéromone est accentuée.
Si ce n'est pas le cas, la trace est diminuée. La modification de la trace prend en compte le taux d'amélioration ou de dégradation.
Il faudrait également que la modification prenne en compte le fait d'ouvrir un service ou non.

\section{Relaxation}

Même avec la solution optimale présente dès le début, on passe trop de temps à arpenter l'arbre.
Les deux options sont : avoir une meilleure relaxation et changement l'ordre d'affectation des variables.

\subsection{Qualité de la relxation}

Une possibilté est de résoudre le CFLP ou le UFLP. Problème : ça peut être très long. Après, on peut trouver un compromis entre RC et R/U/C/FLP.
Sinon, il faudrait ajouter des inégalités valides. ça a quand même l'air compliqué dans les papiers >.<

\subsection{Ordre d'affectation}

Ce qui m'embête : peut être uniquement un choix heuristique. Pas facile de déterminer un ordre qui conduit forcément à une résolution plus rapide.
On peut toujours faire des tests.

\section{à changer}

Plusieurs choses qui ne vont pas. Lorsqu'on connecte le client, on ne vérifie pas si le service est bien ouvert.
Ensuite, on peut juste calculer rapidement si les services ouverts cumulents une offre suffisante pour les clients -> ça ne sert à rien de tester les clients si uniquement un service est ouvert.

\section{modèle glpk}

On peut changer le modèle de glpk. Rajouter les y_ij <= x_i
